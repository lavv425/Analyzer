{"ast":null,"code":"/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n  if (!obj) {\n    return null;\n  }\n  const {\n    dotIndex,\n    key,\n    remaining\n  } = state(kp);\n  const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n  const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n  if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n    const {\n      key: nextKey\n    } = state(remaining);\n    const nextKeyAsInt = parseInt(nextKey);\n    // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n    if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {\n      return keyVal.map(doc => evaluatePath(doc, remaining));\n    }\n    // Otherwise, we can just recur\n    return evaluatePath(keyVal, remaining);\n  } else if (Array.isArray(obj)) {\n    const keyAsInt = parseInt(key);\n    if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n      return keyVal;\n    }\n    // If this object is actually an array, then iterate over those items evaluating the path\n    return obj.map(doc => evaluatePath(doc, kp));\n  } else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n    // If there's a field with a non-nested dot, then recur into that sub-value\n    return evaluatePath(keyVal, remaining);\n  } else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n    // If the field is here, but the key was escaped\n    return keyVal;\n  }\n  // Otherwise, we can just return value directly\n  return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n  if (!obj) {\n    throw new Error('No object was provided.');\n  } else if (!kp) {\n    throw new Error('No keyPath was provided.');\n  }\n  return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n  const {\n    dotIndex,\n    key,\n    remaining\n  } = state(kp);\n  // If this is clearly a prototype pollution attempt, then refuse to modify the path\n  if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n    return obj;\n  }\n  if (dotIndex >= 0) {\n    const keyAsInt = parseInt(key);\n    // If there is a '.' in the key path, recur on the subdoc and ...\n    if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {\n      var _obj$key;\n      // If there's no value at obj[key] then populate an empty object\n      obj[key] = (_obj$key = obj[key]) !== null && _obj$key !== void 0 ? _obj$key : {};\n      // Continue iterating on the rest of the key path to set the appropriate value where intended and then return\n      _sp(obj[key], remaining, v);\n      return obj;\n    } else if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n      // If this is an array and there are multiple levels of keys to iterate over, recur.\n      obj.forEach(doc => _sp(doc, kp, v));\n      return obj;\n    } else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n      const {\n        key: nextKey\n      } = state(remaining);\n      const nextKeyAsInt = parseInt(nextKey);\n      if (!isNaN(nextKeyAsInt)) {\n        // If the current key doesn't exist yet and the next key is a number (likely array index), populate an empty array\n        obj[key] = [];\n      } else if (remaining === '') {\n        // If the remaining key is empty, then a `.` character appeared right at the end of the path and wasn't actually indicating a separate level\n        obj[kp] = v;\n        return obj;\n      } else {\n        // If the current key doesn't exist yet, populate it\n        obj[key] = {};\n      }\n    }\n    _sp(obj[key], remaining, v);\n  } else if (Array.isArray(obj)) {\n    const keyAsInt = parseInt(key);\n    // If the object is an array and this key is an int (likely array index), then set the value directly and return\n    if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n      obj[key] = v;\n      return obj;\n    }\n    // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n    obj.forEach(doc => _sp(doc, remaining, v));\n    return obj;\n  } else {\n    // Otherwise, we can set the path directly\n    obj[key] = v;\n  }\n  return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n  const dotIndex = findFirstNonEscapedDotIndex(kp);\n  return {\n    dotIndex,\n    key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n    remaining: kp.slice(dotIndex + 1)\n  };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n  for (let i = 0; i < kp.length; i++) {\n    const previousChar = i > 0 ? kp[i - 1] : '',\n      currentChar = kp[i];\n    if (currentChar === '.' && previousChar !== '\\\\') return i;\n  }\n  return -1;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","setPath","evaluatePath","obj","kp","dotIndex","key","remaining","state","kpVal","undefined","keyVal","nextKey","nextKeyAsInt","parseInt","Array","isArray","isNaN","map","doc","keyAsInt","v","Error","_sp","startsWith","_obj$key","forEach","findFirstNonEscapedDotIndex","slice","replace","i","length","previousChar","currentChar"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/projects/ticket/analyzer/node_modules/doc-path/lib/path.js"],"sourcesContent":["/**\n * @license MIT\n * doc-path <https://github.com/mrodrig/doc-path>\n * Copyright (c) 2015-present, Michael Rodrigues.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setPath = exports.evaluatePath = void 0;\n/**\n * Main function that evaluates the path in a particular object\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction evaluatePath(obj, kp) {\n    if (!obj) {\n        return null;\n    }\n    const { dotIndex, key, remaining } = state(kp);\n    const kpVal = typeof obj === 'object' && kp in obj ? obj[kp] : undefined;\n    const keyVal = typeof obj === 'object' && key in obj ? obj[key] : undefined;\n    if (dotIndex >= 0 && typeof obj === 'object' && !(kp in obj)) {\n        const { key: nextKey } = state(remaining);\n        const nextKeyAsInt = parseInt(nextKey);\n        // If there's an array at the current key in the object, then iterate over those items evaluating the remaining path\n        if (Array.isArray(keyVal) && isNaN(nextKeyAsInt)) {\n            return keyVal.map((doc) => evaluatePath(doc, remaining));\n        }\n        // Otherwise, we can just recur\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            return keyVal;\n        }\n        // If this object is actually an array, then iterate over those items evaluating the path\n        return obj.map((doc) => evaluatePath(doc, kp));\n    }\n    else if (dotIndex >= 0 && kp !== key && typeof obj === 'object' && key in obj) {\n        // If there's a field with a non-nested dot, then recur into that sub-value\n        return evaluatePath(keyVal, remaining);\n    }\n    else if (dotIndex === -1 && typeof obj === 'object' && key in obj && !(kp in obj)) {\n        // If the field is here, but the key was escaped\n        return keyVal;\n    }\n    // Otherwise, we can just return value directly\n    return kpVal;\n}\nexports.evaluatePath = evaluatePath;\n/**\n * Main function that performs validation before passing off to _sp\n * @throws {Error} possible error if call stack size is exceeded\n */\nfunction setPath(obj, kp, v) {\n    if (!obj) {\n        throw new Error('No object was provided.');\n    }\n    else if (!kp) {\n        throw new Error('No keyPath was provided.');\n    }\n    return _sp(obj, kp, v);\n}\nexports.setPath = setPath;\n// Helper function that will set the value in the provided object/array.\nfunction _sp(obj, kp, v) {\n    const { dotIndex, key, remaining } = state(kp);\n    // If this is clearly a prototype pollution attempt, then refuse to modify the path\n    if (kp.startsWith('__proto__') || kp.startsWith('constructor') || kp.startsWith('prototype')) {\n        return obj;\n    }\n    if (dotIndex >= 0) {\n        const keyAsInt = parseInt(key);\n        // If there is a '.' in the key path, recur on the subdoc and ...\n        if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj) && !isNaN(keyAsInt)) {\n            // If there's no value at obj[key] then populate an empty object\n            obj[key] = obj[key] ?? {};\n            // Continue iterating on the rest of the key path to set the appropriate value where intended and then return\n            _sp(obj[key], remaining, v);\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && Array.isArray(obj)) {\n            // If this is an array and there are multiple levels of keys to iterate over, recur.\n            obj.forEach((doc) => _sp(doc, kp, v));\n            return obj;\n        }\n        else if (typeof obj === 'object' && obj !== null && !(key in obj) && !Array.isArray(obj)) {\n            const { key: nextKey } = state(remaining);\n            const nextKeyAsInt = parseInt(nextKey);\n            if (!isNaN(nextKeyAsInt)) {\n                // If the current key doesn't exist yet and the next key is a number (likely array index), populate an empty array\n                obj[key] = [];\n            }\n            else if (remaining === '') {\n                // If the remaining key is empty, then a `.` character appeared right at the end of the path and wasn't actually indicating a separate level\n                obj[kp] = v;\n                return obj;\n            }\n            else {\n                // If the current key doesn't exist yet, populate it\n                obj[key] = {};\n            }\n        }\n        _sp(obj[key], remaining, v);\n    }\n    else if (Array.isArray(obj)) {\n        const keyAsInt = parseInt(key);\n        // If the object is an array and this key is an int (likely array index), then set the value directly and return\n        if (kp === key && dotIndex === -1 && !isNaN(keyAsInt)) {\n            obj[key] = v;\n            return obj;\n        }\n        // If this \"obj\" is actually an array, then we can loop over each of the values and set the path\n        obj.forEach((doc) => _sp(doc, remaining, v));\n        return obj;\n    }\n    else {\n        // Otherwise, we can set the path directly\n        obj[key] = v;\n    }\n    return obj;\n}\n// Helper function that returns some information necessary to evaluate or set a path  based on the provided keyPath value\nfunction state(kp) {\n    const dotIndex = findFirstNonEscapedDotIndex(kp);\n    return {\n        dotIndex,\n        key: kp.slice(0, dotIndex >= 0 ? dotIndex : undefined).replace(/\\\\./g, '.'),\n        remaining: kp.slice(dotIndex + 1)\n    };\n}\nfunction findFirstNonEscapedDotIndex(kp) {\n    for (let i = 0; i < kp.length; i++) {\n        const previousChar = i > 0 ? kp[i - 1] : '', currentChar = kp[i];\n        if (currentChar === '.' && previousChar !== '\\\\')\n            return i;\n    }\n    return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}