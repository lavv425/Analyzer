{"ast":null,"code":"const {\n  parseJson,\n  getByProperty,\n  compare\n} = require('./Helpers');\nconst QueryManager = require('./QueryManager');\nclass JSJsonQ {\n  /**\n   * constructor - A JSJsonQ Object can be initialized with a filepath{type: string}\n   * or a Json String{type: string} or a Json Object {type: Object}\n   *\n   * @param {string|Object} json required\n   *\n   * @returns\n   * @throws {Error}\n   */\n  constructor(json) {\n    if (!json) {\n      throw Error('You must pass a filePath or a Json Object or a Json String as parameter');\n    }\n    this._baseContent = parseJson(json);\n    this._queryManager = new QueryManager();\n    this.reset();\n  }\n\n  /**\n   * reset - A JsonQuery Object can be reset to new data according to the\n   * given filepath{type: string} or a Json String{type: string}\n   * or a Json Object {type: Object}.\n   * The method parameter 'data' is optional. If no 'data' given,\n   * the JsonQuery Object will be reset to the previously initialized data.\n   * All the query and processing done so far will be reset to initial state too.\n   *\n   * @param {string|Object} data optional\n   *\n   * @returns {JsonQuery} Object reference\n   */\n  reset(data) {\n    data = parseJson(data || this._baseContent);\n    if (Array.isArray(data)) {\n      this._jsonContent = Array.from(data);\n    } else {\n      this._jsonContent = Object.assign({}, data);\n    }\n    this._queryManager.reset();\n    return this;\n  }\n\n  /**\n   * copy - Clone and return the exact same copy of the this Object instance\n   *\n   * @returns {JsonQuery}\n   */\n  copy() {\n    return Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n  }\n\n  /**\n   * _prepare - Pseudo private method to process data based on the queries\n   *\n   * @returns {None}\n   */\n  _prepare() {\n    this._jsonContent = this._queryManager.prepare(this._jsonContent);\n  }\n\n  /**\n   * fetch - get the processed data after executing queries\n   *\n   * @returns {mixed}\n   */\n  fetch() {\n    this._prepare();\n    return this._jsonContent;\n  }\n\n  /**\n   * at - get the data traversing through the given path hierarchy\n   * Will return the JsonQuery Object instance, so that further\n   * Query can be done on that data\n   *\n   * @param {string} path path hierarchy as a string, separated by '.'\n   *\n   * @returns {JsonQuery} Object reference\n   */\n  at(path) {\n    const keyParts = path.trim().split('.').filter(val => val != '');\n    for (const key of keyParts) {\n      this._jsonContent = getByProperty(key, this._jsonContent);\n    }\n    return this;\n  }\n\n  /**\n   * from - Alias method of at()\n   *\n   * @param {type} path Description\n   *\n   * @returns {type} Description\n   */\n  from(path) {\n    return this.at(path);\n  }\n\n  /* ------------------------- Query Methods ------------------------- */\n\n  /**\n   * find - get the data traversing through the given path hierarchy\n   * works like at() method, except it will return the processed data.\n   * So, no further query method can be chained on it.\n   *\n   * @param {type} path Description\n   *\n   * @returns {mixed} Description\n   * @throws {Error}\n   */\n  find(path) {\n    if (!path) {\n      throw Error('Invalid parameter given');\n    }\n    return this.at(path).fetch();\n  }\n\n  /**\n   * where - This method is avaialble to run different types of Query on data,\n   * such as if the given key is equal to, not equal to, greater than, less than\n   * etc.\n   * Details can be found at Example.\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {string} op  operator (valid operator lists are defined in Matcher Class)\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  where(key, op, val) {\n    if (key instanceof Function) {\n      key(this);\n    } else {\n      this._queryManager.insertQuery({\n        key,\n        op,\n        val\n      });\n    }\n    return this;\n  }\n\n  /**\n   * orWhere - This method is avaialble to run different types of Query on data,\n   * such as if the given key is equal to, not equal to, greater than, less than\n   * etc. These queries will be ORed with other queries.\n   * Details can be found at Example.\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {string} op  operator (valid operator lists are defined in Matcher Class)\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  orWhere(key, op) {\n    let val = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    // For a 'Or' type query, every time a new Query group will be created\n    this._queryManager.createQueryGroup();\n    if (key instanceof Function) {\n      key(this);\n    } else {\n      this._queryManager.insertQuery({\n        key,\n        op,\n        val\n      });\n    }\n    return this;\n  }\n\n  /**\n   * whereIn - alias for method call: where(key, 'in', array)\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereIn(key, val) {\n    return this.where(key, 'in', val);\n  }\n\n  /**\n   * whereNotIn - alias for method call: where(key, 'notin', array)\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereNotIn(key, val) {\n    return this.where(key, 'notin', val);\n  }\n\n  /**\n   * whereNull - alias for method call: where(key, 'null')\n   *\n   * @param {string} key 'key' to be searched for\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereNull(key) {\n    return this.where(key, 'null');\n  }\n\n  /**\n   * whereNotNull - alias for method call: where(key, 'notnull')\n   *\n   * @param {string} key 'key' to be searched for\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereNotNull(key) {\n    return this.where(key, 'notnull');\n  }\n\n  /**\n   * whereStartsWith - alias for method call: where(key, 'startswith', val)\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereStartsWith(key, val) {\n    return this.where(key, 'startswith', val);\n  }\n\n  /**\n   * whereEndsWith - alias for method call: where(key, 'endswith', val)\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereEndsWith(key, val) {\n    return this.where(key, 'endswith', val);\n  }\n\n  /**\n   * whereContains - alias for method call: where(key, 'contains', val)\n   *\n   * @param {string} key 'key' to be searched for\n   * @param {mixed|Function} val can be a data or an anonymous function\n   *\n   * @returns {JsonQuery} Object instance\n   */\n  whereContains(key, val) {\n    return this.where(key, 'contains', val);\n  }\n\n  /* --------------------- Aggregate Methods ------------------------- */\n\n  /**\n   * sum - If a 'property' given as parameter this method will return the summation\n   * result of the collection contains that property, otherwise it will assume\n   * that the collection is an integer array and just return sum of all of them\n   *\n   * @param {string} property\n   *\n   * @returns {int|float}\n   */\n  sum(property) {\n    this._prepare();\n    return this._jsonContent.reduce((acc, current) => Number(acc) + Number(property ? current[property] : current), 0);\n  }\n\n  /**\n   * count - returns the size of the collection\n   *\n   * @returns {int}\n   */\n  count() {\n    this._prepare();\n    return this._jsonContent.length;\n  }\n\n  /**\n   * size - returns the size of the collection\n   *\n   * @returns {int}\n   */\n  size() {\n    return this.count();\n  }\n\n  /**\n   * max - If a 'property' given as parameter this method will return the maximum\n   * value of the collection contains that property, otherwise it will assume\n   * that the collection is an integer array and just return maximum of them\n   *\n   * @param {string} property\n   *\n   * @returns {int|float}\n   */\n  max(property) {\n    this._prepare();\n    return this._jsonContent.reduce((max, current) => {\n      const elem = property ? current[property] : current;\n      return max > elem ? max : elem;\n    }, property ? this._jsonContent[0][property] : this._jsonContent[0]);\n  }\n\n  /**\n   * min - If a 'property' given as parameter this method will return the minimum\n   * value of the collection contains that property, otherwise it will assume\n   * that the collection is an integer array and just return minimum of them\n   *\n   * @param {string} property\n   *\n   * @returns {int|float}\n   */\n  min(property) {\n    this._prepare();\n    return this._jsonContent.reduce((min, current) => {\n      const elem = property ? current[property] : current;\n      return min < elem ? min : elem;\n    }, property ? this._jsonContent[0][property] : this._jsonContent[0]);\n  }\n\n  /**\n   * avg - returns the average of the result by summing up the values of\n   * given property divided by their count\n   *\n   * @returns {int|float}\n   */\n  avg(property) {\n    this._prepare();\n    return this.sum(property) / this.count();\n  }\n\n  /**\n   * first - Returns the first element of the collection\n   *\n   * @returns {mixed}\n   */\n  first() {\n    this._prepare();\n    return this.count() > 0 ? this._jsonContent[0] : null;\n  }\n\n  /**\n   * last - Returns the last element of the collection\n   *\n   * @returns {mixed}\n   */\n  last() {\n    this._prepare();\n    return this.count() > 0 ? this._jsonContent[this.count() - 1] : null;\n  }\n\n  /**\n   * nth - Returns the nth element of the collection by the given index (n)\n   * if the given index is negative, such as -2, it will return the value of\n   * nth index from the end.\n   *\n   * @returns {mixed}\n   */\n  nth(index) {\n    this._prepare();\n    const abs_index = Math.abs(index);\n    if (!Number.isInteger(index) || this.count() < abs_index || index == 0) return null;\n    return index > 0 ? this._jsonContent[index - 1] : this._jsonContent[this.count() + index];\n  }\n\n  /**\n   * exists - Check if the content is empty or null\n   *\n   * @returns {boolean}\n   */\n  exists() {\n    this._prepare();\n    if (Array.isArray(this._jsonContent)) {\n      return this._jsonContent.length > 0;\n    } else if (this._jsonContent instanceof Object && this._jsonContent.constructor === Object) {\n      return Object.keys(this._jsonContent).length > 0;\n    }\n    return !!this._jsonContent;\n  }\n\n  /**\n   * groupBy - return the grouped result by the given property\n   *\n   * @param {string} property\n   *\n   * @returns {Array}\n   */\n  groupBy(property) {\n    if (!property) {\n      throw Error(\"A 'property' parameter must be given to groupBy() method\");\n    }\n    this._prepare();\n    const groupedData = {};\n    this._jsonContent.forEach(data => {\n      if (property in data) {\n        if (!(data[property] in groupedData)) {\n          groupedData[data[property]] = [];\n        }\n        groupedData[data[property]].push(data);\n      }\n    });\n    this._jsonContent = groupedData;\n    return this;\n  }\n\n  /**\n   * sort - return the sorted result of the given collection.\n   * By default, the result would be sorted as 'Ascending'. If you want to\n   * sort the result as 'Descending', pass 'desc' as the parameter.\n   * If you want to define a different logic for sorting, pass a compare\n   * Function as parameter.\n   *\n   * This method should be used for array of integers or floats.\n   * If you want to sort an array of Objects by a specific property,\n   * use sortBy() method.\n   *\n   * @param {string|Function} [order=asc]\n   *\n   * @returns {mixed}\n   */\n  sort() {\n    let order = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'asc';\n    this._prepare();\n    if (!Array.isArray(this._jsonContent)) {\n      return this;\n    }\n    this._jsonContent.sort((a, b) => {\n      return compare(a, b, order);\n    });\n    return this;\n  }\n\n  /**\n   * sortBy - return the sorted result of the given collection by the given\n   * property.\n   * By default, the result would be sorted as 'Ascending'. If you want to\n   * sort the result as 'Descending', pass 'desc' as the second parameter.\n   * If you want to define a different logic for sorting, pass a compare\n   * Function as second parameter.\n   *\n   * This method should be used for array of Objects.\n   * If you want to sort an array of integers or floats, use sort() method.\n   *\n   * @param {string} property\n   * @param {string|Function} property\n   * @returns {mixed}\n   * @throws {Error}\n   */\n  sortBy(property) {\n    let order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asc';\n    if (!property) {\n      throw Error(\"A 'property' parameter must be given to sortAs() method\");\n    }\n    this._prepare();\n    if (!Array.isArray(this._jsonContent)) {\n      return this;\n    }\n    this._jsonContent.sort((a, b) => {\n      if (a instanceof Object && property in a) {\n        a = a[property];\n      }\n      if (b instanceof Object && property in b) {\n        b = b[property];\n      }\n      return compare(a, b, order);\n    });\n    return this;\n  }\n}\nmodule.exports = JSJsonQ;","map":{"version":3,"names":["parseJson","getByProperty","compare","require","QueryManager","JSJsonQ","constructor","json","Error","_baseContent","_queryManager","reset","data","Array","isArray","_jsonContent","from","Object","assign","copy","create","getPrototypeOf","_prepare","prepare","fetch","at","path","keyParts","trim","split","filter","val","key","find","where","op","Function","insertQuery","orWhere","arguments","length","undefined","createQueryGroup","whereIn","whereNotIn","whereNull","whereNotNull","whereStartsWith","whereEndsWith","whereContains","sum","property","reduce","acc","current","Number","count","size","max","elem","min","avg","first","last","nth","index","abs_index","Math","abs","isInteger","exists","keys","groupBy","groupedData","forEach","push","sort","order","a","b","sortBy","module","exports"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/projects/ticket/analyzer/node_modules/js-jsonq/index.js"],"sourcesContent":["const { parseJson, getByProperty, compare } = require('./Helpers');\nconst QueryManager = require('./QueryManager');\n\nclass JSJsonQ {\n    /**\n     * constructor - A JSJsonQ Object can be initialized with a filepath{type: string}\n     * or a Json String{type: string} or a Json Object {type: Object}\n     *\n     * @param {string|Object} json required\n     *\n     * @returns\n     * @throws {Error}\n     */\n    constructor(json) {\n        if (!json) {\n            throw Error(\n                'You must pass a filePath or a Json Object or a Json String as parameter'\n            );\n        }\n\n        this._baseContent = parseJson(json);\n\n        this._queryManager = new QueryManager();\n\n        this.reset();\n    }\n\n    /**\n     * reset - A JsonQuery Object can be reset to new data according to the\n     * given filepath{type: string} or a Json String{type: string}\n     * or a Json Object {type: Object}.\n     * The method parameter 'data' is optional. If no 'data' given,\n     * the JsonQuery Object will be reset to the previously initialized data.\n     * All the query and processing done so far will be reset to initial state too.\n     *\n     * @param {string|Object} data optional\n     *\n     * @returns {JsonQuery} Object reference\n     */\n    reset(data) {\n        data = parseJson(data || this._baseContent);\n\n        if (Array.isArray(data)) {\n            this._jsonContent = Array.from(data);\n        } else {\n            this._jsonContent = Object.assign({}, data);\n        }\n\n        this._queryManager.reset();\n\n        return this;\n    }\n\n    /**\n     * copy - Clone and return the exact same copy of the this Object instance\n     *\n     * @returns {JsonQuery}\n     */\n    copy() {\n        return Object.assign(Object.create(Object.getPrototypeOf(this)), this);\n    }\n\n    /**\n     * _prepare - Pseudo private method to process data based on the queries\n     *\n     * @returns {None}\n     */\n    _prepare() {\n        this._jsonContent = this._queryManager.prepare(this._jsonContent);\n    }\n\n    /**\n     * fetch - get the processed data after executing queries\n     *\n     * @returns {mixed}\n     */\n    fetch() {\n        this._prepare();\n\n        return this._jsonContent;\n    }\n\n    /**\n     * at - get the data traversing through the given path hierarchy\n     * Will return the JsonQuery Object instance, so that further\n     * Query can be done on that data\n     *\n     * @param {string} path path hierarchy as a string, separated by '.'\n     *\n     * @returns {JsonQuery} Object reference\n     */\n    at(path) {\n        const keyParts = path\n            .trim()\n            .split('.')\n            .filter(val => val != '');\n\n        for (const key of keyParts) {\n            this._jsonContent = getByProperty(key, this._jsonContent);\n        }\n\n        return this;\n    }\n\n    /**\n     * from - Alias method of at()\n     *\n     * @param {type} path Description\n     *\n     * @returns {type} Description\n     */\n    from(path) {\n        return this.at(path);\n    }\n\n    /* ------------------------- Query Methods ------------------------- */\n\n    /**\n     * find - get the data traversing through the given path hierarchy\n     * works like at() method, except it will return the processed data.\n     * So, no further query method can be chained on it.\n     *\n     * @param {type} path Description\n     *\n     * @returns {mixed} Description\n     * @throws {Error}\n     */\n    find(path) {\n        if (!path) {\n            throw Error('Invalid parameter given');\n        }\n        return this.at(path).fetch();\n    }\n\n    /**\n     * where - This method is avaialble to run different types of Query on data,\n     * such as if the given key is equal to, not equal to, greater than, less than\n     * etc.\n     * Details can be found at Example.\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {string} op  operator (valid operator lists are defined in Matcher Class)\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    where(key, op, val) {\n        if (key instanceof Function) {\n            key(this);\n        } else {\n            this._queryManager.insertQuery({ key, op, val });\n        }\n\n        return this;\n    }\n\n    /**\n     * orWhere - This method is avaialble to run different types of Query on data,\n     * such as if the given key is equal to, not equal to, greater than, less than\n     * etc. These queries will be ORed with other queries.\n     * Details can be found at Example.\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {string} op  operator (valid operator lists are defined in Matcher Class)\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    orWhere(key, op, val = null) {\n        // For a 'Or' type query, every time a new Query group will be created\n        this._queryManager.createQueryGroup();\n\n        if (key instanceof Function) {\n            key(this);\n        } else {\n            this._queryManager.insertQuery({ key, op, val });\n        }\n\n        return this;\n    }\n\n    /**\n     * whereIn - alias for method call: where(key, 'in', array)\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereIn(key, val) {\n        return this.where(key, 'in', val);\n    }\n\n    /**\n     * whereNotIn - alias for method call: where(key, 'notin', array)\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereNotIn(key, val) {\n        return this.where(key, 'notin', val);\n    }\n\n    /**\n     * whereNull - alias for method call: where(key, 'null')\n     *\n     * @param {string} key 'key' to be searched for\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereNull(key) {\n        return this.where(key, 'null');\n    }\n\n    /**\n     * whereNotNull - alias for method call: where(key, 'notnull')\n     *\n     * @param {string} key 'key' to be searched for\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereNotNull(key) {\n        return this.where(key, 'notnull');\n    }\n\n    /**\n     * whereStartsWith - alias for method call: where(key, 'startswith', val)\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereStartsWith(key, val) {\n        return this.where(key, 'startswith', val);\n    }\n\n    /**\n     * whereEndsWith - alias for method call: where(key, 'endswith', val)\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereEndsWith(key, val) {\n        return this.where(key, 'endswith', val);\n    }\n\n    /**\n     * whereContains - alias for method call: where(key, 'contains', val)\n     *\n     * @param {string} key 'key' to be searched for\n     * @param {mixed|Function} val can be a data or an anonymous function\n     *\n     * @returns {JsonQuery} Object instance\n     */\n    whereContains(key, val) {\n        return this.where(key, 'contains', val);\n    }\n\n    /* --------------------- Aggregate Methods ------------------------- */\n\n    /**\n     * sum - If a 'property' given as parameter this method will return the summation\n     * result of the collection contains that property, otherwise it will assume\n     * that the collection is an integer array and just return sum of all of them\n     *\n     * @param {string} property\n     *\n     * @returns {int|float}\n     */\n    sum(property) {\n        this._prepare();\n\n        return this._jsonContent.reduce(\n            (acc, current) =>\n                Number(acc) + Number(property ? current[property] : current),\n            0\n        );\n    }\n\n    /**\n     * count - returns the size of the collection\n     *\n     * @returns {int}\n     */\n    count() {\n        this._prepare();\n\n        return this._jsonContent.length;\n    }\n\n    /**\n     * size - returns the size of the collection\n     *\n     * @returns {int}\n     */\n    size() {\n        return this.count();\n    }\n\n    /**\n     * max - If a 'property' given as parameter this method will return the maximum\n     * value of the collection contains that property, otherwise it will assume\n     * that the collection is an integer array and just return maximum of them\n     *\n     * @param {string} property\n     *\n     * @returns {int|float}\n     */\n    max(property) {\n        this._prepare();\n\n        return this._jsonContent.reduce((max, current) => {\n            const elem = property ? current[property] : current;\n\n            return max > elem ? max : elem;\n        }, property ? this._jsonContent[0][property] : this._jsonContent[0]);\n    }\n\n    /**\n     * min - If a 'property' given as parameter this method will return the minimum\n     * value of the collection contains that property, otherwise it will assume\n     * that the collection is an integer array and just return minimum of them\n     *\n     * @param {string} property\n     *\n     * @returns {int|float}\n     */\n    min(property) {\n        this._prepare();\n\n        return this._jsonContent.reduce((min, current) => {\n            const elem = property ? current[property] : current;\n\n            return min < elem ? min : elem;\n        }, property ? this._jsonContent[0][property] : this._jsonContent[0]);\n    }\n\n    /**\n     * avg - returns the average of the result by summing up the values of\n     * given property divided by their count\n     *\n     * @returns {int|float}\n     */\n    avg(property) {\n        this._prepare();\n\n        return this.sum(property) / this.count();\n    }\n\n    /**\n     * first - Returns the first element of the collection\n     *\n     * @returns {mixed}\n     */\n    first() {\n        this._prepare();\n\n        return this.count() > 0 ? this._jsonContent[0] : null;\n    }\n\n    /**\n     * last - Returns the last element of the collection\n     *\n     * @returns {mixed}\n     */\n    last() {\n        this._prepare();\n\n        return this.count() > 0 ? this._jsonContent[this.count() - 1] : null;\n    }\n\n    /**\n     * nth - Returns the nth element of the collection by the given index (n)\n     * if the given index is negative, such as -2, it will return the value of\n     * nth index from the end.\n     *\n     * @returns {mixed}\n     */\n    nth(index) {\n        this._prepare();\n\n        const abs_index = Math.abs(index);\n\n        if (!Number.isInteger(index) || this.count() < abs_index || index == 0)\n            return null;\n\n        return index > 0\n            ? this._jsonContent[index - 1]\n            : this._jsonContent[this.count() + index];\n    }\n\n    /**\n     * exists - Check if the content is empty or null\n     *\n     * @returns {boolean}\n     */\n    exists() {\n        this._prepare();\n\n        if (Array.isArray(this._jsonContent)) {\n            return this._jsonContent.length > 0;\n        } else if (\n            this._jsonContent instanceof Object &&\n            this._jsonContent.constructor === Object\n        ) {\n            return Object.keys(this._jsonContent).length > 0;\n        }\n\n        return !!this._jsonContent;\n    }\n\n    /**\n     * groupBy - return the grouped result by the given property\n     *\n     * @param {string} property\n     *\n     * @returns {Array}\n     */\n    groupBy(property) {\n        if (!property) {\n            throw Error(\n                `A 'property' parameter must be given to groupBy() method`\n            );\n        }\n\n        this._prepare();\n\n        const groupedData = {};\n\n        this._jsonContent.forEach(data => {\n            if (property in data) {\n                if (!(data[property] in groupedData)) {\n                    groupedData[data[property]] = [];\n                }\n\n                groupedData[data[property]].push(data);\n            }\n        });\n\n        this._jsonContent = groupedData;\n\n        return this;\n    }\n\n    /**\n     * sort - return the sorted result of the given collection.\n     * By default, the result would be sorted as 'Ascending'. If you want to\n     * sort the result as 'Descending', pass 'desc' as the parameter.\n     * If you want to define a different logic for sorting, pass a compare\n     * Function as parameter.\n     *\n     * This method should be used for array of integers or floats.\n     * If you want to sort an array of Objects by a specific property,\n     * use sortBy() method.\n     *\n     * @param {string|Function} [order=asc]\n     *\n     * @returns {mixed}\n     */\n    sort(order = 'asc') {\n        this._prepare();\n\n        if (!Array.isArray(this._jsonContent)) {\n            return this;\n        }\n\n        this._jsonContent.sort((a, b) => {\n            return compare(a, b, order);\n        });\n\n        return this;\n    }\n\n    /**\n     * sortBy - return the sorted result of the given collection by the given\n     * property.\n     * By default, the result would be sorted as 'Ascending'. If you want to\n     * sort the result as 'Descending', pass 'desc' as the second parameter.\n     * If you want to define a different logic for sorting, pass a compare\n     * Function as second parameter.\n     *\n     * This method should be used for array of Objects.\n     * If you want to sort an array of integers or floats, use sort() method.\n     *\n     * @param {string} property\n     * @param {string|Function} property\n     * @returns {mixed}\n     * @throws {Error}\n     */\n    sortBy(property, order = 'asc') {\n        if (!property) {\n            throw Error(\n                `A 'property' parameter must be given to sortAs() method`\n            );\n        }\n\n        this._prepare();\n\n        if (!Array.isArray(this._jsonContent)) {\n            return this;\n        }\n\n        this._jsonContent.sort((a, b) => {\n            if (a instanceof Object && property in a) {\n                a = a[property];\n            }\n\n            if (b instanceof Object && property in b) {\n                b = b[property];\n            }\n\n            return compare(a, b, order);\n        });\n\n        return this;\n    }\n}\n\nmodule.exports = JSJsonQ;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}